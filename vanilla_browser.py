# -*- coding: utf-8 -*-
"""
/***************************************************************************
 VanillaBrowser
                                 A QGIS plugin
 Browser for Vanilla (uses Vanilla API)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-01-04
        git sha              : $Format:%H$
        copyright            : (C) 2024 by MSE @ BPM-Conseil
        email                : matthieu.serek@bpm-conseil.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QMainWindow
from qgis.core import QgsProject, QgsFields, QgsVectorLayer, QgsField, QgsGeometry, QgsFeature,  QgsVectorFileWriter, QgsWkbTypes, QgsApplication, QgsMapLayer
from qgis.analysis import QgsNativeAlgorithms
from processing.core.Processing import Processing

from PyQt5 import QtWidgets
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .vanilla_browser_dialog import VanillaBrowserDialog
from .vanilla_browser_dialog_logins import Ui_LoginWindow
from .vanilla_browser_dialog_layers import Ui_ChooseLayer
from .vanilla_browser_dialog_editsessions import Ui_EditSessions
from .vanilla_browser_dialog_createsession import Ui_CreateSession
from .vanilla_browser_dialog_createcontract import Ui_createContract
import os.path
import requests
import csv
import json
from datetime import datetime

import importlib
import subprocess

try:
    importlib.import_module('cryptography')
except ImportError:
    import subprocess
    subprocess.check_call(['python', '-m', 'pip', 'install', '--upgrade', 'pip'])
    subprocess.check_call(['python', '-m', 'pip', 'install', 'cryptography'])

from cryptography.fernet import Fernet
# Classe pour la fenêtre de prévisualisation
class TableWindow(QMainWindow):
    def __init__(self, parent=None):
        super(TableWindow, self).__init__(parent)
        self.setWindowTitle("Tableau")
        self.setGeometry(300, 300, 500, 400)

        self.table = QtWidgets.QTableWidget(self)
        self.setCentralWidget(self.table)

class VanillaBrowser:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'VanillaBrowser_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Vanilla Browser')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.allTables = None
        self.queryLimit = '0'
        self.queryDistinct = 'false'
        self.fernet = None
        
        if not os.path.exists(os.path.expanduser("~") + '/.vanillaplugin/'):
            os.makedirs(os.path.expanduser("~") + '/.vanillaplugin/')

        destination_folder = os.path.expanduser("~") + '/.vanillaplugin/'
        json_file_path = os.path.join(destination_folder, 'sessions.json')

        if not os.path.exists(json_file_path):
            with open(json_file_path, 'w') as f:
                data = {
                    'sessions': []
                }
                json.dump(data, f)
        
        self.enum_geo = ['geo_point_2d','coordonnees',"coordonnées",'geoloc','geo_point','coordin','coordon','geopoint','geoPoint','pav_positiont2d','wgs84','equgpsy_x','geoban','codegeo','latlon','lat_lon']
        self.enum_tuples_geo = [('latitude', 'longitude'), ('lat', 'lon'), ('lat', 'lng'), ('lat', 'long'), ('lat_x', 'lon_y'), ('xlat','ylong')]
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('VanillaBrowser', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/vanilla_browser/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'This extension connects to Vanilla resources (Metadata, Architect) and allow to manipulate its resources to create Qgis layers'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Vanilla Browser'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.read()
            self.dlg = VanillaBrowserDialog()
            # Cacher certaines fonctionnalités
            self.dlg.label_lon.setHidden(True)
            self.dlg.combo_lon.setHidden(True)
            self.dlg.combo_NColumn.setEnabled(False)
            self.dlg.combo_lat.setEnabled(False)
            self.dlg.push_createQuery.setHidden(True)
            self.dlg.check_centroide.setHidden(True)

            self.dlg.pushLogins.clicked.connect(self.connect_to_vanilla)
            self.dlg.push_searchMetadatas.clicked.connect(self.activate_search_metadatas)
            self.dlg.comboBox_metadata.currentIndexChanged.connect(self.get_models)
            self.dlg.comboBox_model.currentIndexChanged.connect(self.get_packages)
            self.dlg.comboBox_package.currentIndexChanged.connect(self.get_tables)
            self.dlg.list_tables.itemSelectionChanged.connect(self.display_columns)
            self.dlg.combo_NColumn.currentIndexChanged.connect(self.nbColumns)
            self.dlg.list_tables.itemSelectionChanged.connect(self.setComboLatLon)
            self.dlg.push_ImportinQgis.clicked.connect(self.importTableInQgis)
            self.dlg.push_DisplayQueries.clicked.connect(self.dispQueries)
            self.dlg.pushClosePlugin.clicked.connect(self.dlg.close)
            self.dlg.push_getContracts.clicked.connect(self.get_contracts)
            self.dlg.list_contracts.itemSelectionChanged.connect(self.get_contactInfo)
            self.dlg.push_importFromArchitect.clicked.connect(self.importFromArchitect)
            self.dlg.push_exportInArchitect.clicked.connect(self.openChooseFile)
            self.dlg.combo_operation.currentIndexChanged.connect(self.handleComboOp)
            self.dlg.push_Calculate.clicked.connect(self.calculateLayer)
            self.dlg.combo_secondLayer.currentIndexChanged.connect(self.updateListLayers)
            self.dlg.combo_firstLayer.currentIndexChanged.connect(self.updateListLayers)
            self.dlg.check_previsu.stateChanged.connect(self.showPrevisu)
            self.dlg.push_OpenPrevisu.clicked.connect(self.openTableWindow)
            self.dlg.push_newContract.clicked.connect(self.openCrateNewContract)

            self.dlg.tabWidget.currentChanged.connect(self.setupTools)
            self.dlg.combo_firstLayer.currentIndexChanged.connect(self.changeGeoLayers)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def read(self):
        with open(self.plugin_dir + '/help/source/_static/const/temp/mlzkjer.txt', 'rb') as file:
            for line in file:
                self.key = line
            
        self.fernet = Fernet(self.key[2:-1])    
   


    def connect_to_vanilla(self):
        self.windowLogin = QtWidgets.QDialog()
        self.uiLogin =  Ui_LoginWindow()
        self.uiLogin.setupUi(self.windowLogin)
        
        self.uiLogin.comboBox_sessions.addItem('Choisir une session')
        with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'r') as f:
            json_data = json.load(f)
            if json_data['sessions'] != []:
                for session in json_data['sessions']:
                    self.uiLogin.comboBox_sessions.addItem(session['name'])
        
        self.uiLogin.push_editSessions.clicked.connect(self.openSessions)
        self.uiLogin.comboBox_sessions.currentIndexChanged.connect(self.setLoginPassword)
        self.uiLogin.logins_window.loginsEntered.connect(self.getVanillaLogins)
        self.uiLogin.push_close.clicked.connect(self.windowLogin.close)
        self.windowLogin.exec_()

    def setLoginPassword(self):
        index = self.uiLogin.comboBox_sessions.currentIndex()
        if index == -1 or index == 0:
            return
        index = self.uiLogin.comboBox_sessions.currentIndex() - 1
        with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'r') as f:
            json_data = json.load(f)
            session = json_data['sessions'][index]
            self.uiLogin.lineUser.setText(session['login'])
            if session['password'].startswith('b\''):
                pwd = self.fernet.decrypt(session['password'][1:-1])
                pwd = pwd.decode('utf-8')
            else:
                pwd = session['password']
            self.uiLogin.linePassword.setText(pwd)
            self.uiLogin.lineURL.setText(session['url'])

    def getVanillaLogins(self, url, login, password):
        
        vanilla_url = url + '/api/1.0/repositories'

        try:
            response = requests.get(vanilla_url, auth=(login, password))
            if response.status_code == 200:
                response_json = response.json()
                if response_json['status'] == 'success':
                    for repo in response_json['result']:
                        self.dlg.comboBox_repository.addItem(repo['name'], repo['id'])
                    
                    self.dlg.line_vanillaURL.setText(url)
                    response_2 = requests.get(url + '/api/1.0/groups', auth=(login, password))
                    if response_2.status_code == 200:
                        response_json_2 = response_2.json()
                        if response_json_2['status'] == 'success':
                            for group in response_json_2['result']:
                                self.dlg.comboBox_group.addItem(group['name'], group['id'])

                            with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'r') as f:
                                json_data = json.load(f)
                            
                            if json_data['sessions'] == []:

                                with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'w') as f:
                                    if password == '' or password == ' ':
                                        enc_password = ''
                                    else:
                                        enc_password = str(self.fernet.encrypt(password.encode()))
                                    data = {
                                        'name' : login  + ' - ' + url.replace('https://', ''),
                                        'url': url,
                                        'login': login,
                                        'password': enc_password
                                    }
                                    if json_data['sessions'] == []:
                                        json_data['sessions'].append(data)
                                    else:
                                        for session in json_data['sessions']:
                                            if session['url'] == url and session['login'] == login:
                                                json_data['sessions'].remove(session)
                                        json_data['sessions'].append(data)
                                    json.dump(json_data, f)
                            else:
                                isExisting = False
                                for session in json_data['sessions']:
                                    if session['url'] == url and session['login'] == login:
                                        isExisting = True
                                if not isExisting:
                                    with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'w') as f:
                                        if password == '' or password == ' ':
                                            enc_password = ''
                                        else:
                                            enc_password = str(self.fernet.encrypt(password.encode()))
                                        data = {
                                            'name' : login  + ' - ' + url.replace('https://', ''),
                                            'url': url,
                                            'login': login,
                                            'password': enc_password
                                        }
                                        json_data['sessions'].append(data)
                                        json.dump(json_data, f)

                    else:
                        self.uiLogin.label_error.setText('Erreur de connexion')
                self.windowLogin.close()
            else:
                self.uiLogin.label_error.setText('Erreur de connexion')
        except:
            self.uiLogin.label_error.setText('Erreur de connexion')
        
    def openSessions(self):
        self.windowEditSessions = QtWidgets.QDialog()
        self.uiEditSessions =  Ui_EditSessions()
        self.uiEditSessions.setupUi(self.windowEditSessions)

        with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'r') as f:
            json_data = json.load(f)
            for session in json_data['sessions']:
                self.uiEditSessions.list_sessions.addItem(session['name'])
        
        self.uiEditSessions.push_add.clicked.connect(self.addSession)
        self.uiEditSessions.push_edit.clicked.connect(self.editSession)
        self.uiEditSessions.push_delete.clicked.connect(self.deleteSession)
        self.uiEditSessions.pushClose.clicked.connect(self.windowEditSessions.close)
        
        self.windowEditSessions.exec_()

        self.uiLogin.comboBox_sessions.clear()
        self.uiLogin.comboBox_sessions.addItem('Choisir une session')
        with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'r') as f:
            json_data = json.load(f)
            for session in json_data['sessions']:
                self.uiLogin.comboBox_sessions.addItem(session['name'])

    def addSession(self):
        self.windowCreateSession = QtWidgets.QDialog()
        self.uiCreateSession =  Ui_CreateSession()
        self.uiCreateSession.setupUi(self.windowCreateSession)

        self.uiCreateSession.push_Confirm.clicked.connect(self.createSession)
        self.uiCreateSession.pushClose.clicked.connect(self.windowCreateSession.close)

        self.windowCreateSession.exec_()


    def createSession(self):
        
        with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'r') as f:
            json_data = json.load(f)

        if self.uiCreateSession.line_Name.text() == '' or self.uiCreateSession.line_URL.text() == '' or self.uiCreateSession.line_User.text() == '':
            self.show_error_message(self.tr('Veuillez remplir tous les champs'))
            return

        for session in json_data['sessions']:
            if session['name'] == self.uiCreateSession.line_Name.text():
                self.uiCreateSession.label_error.setText('Ce nom de session existe déjà')
                return
            if session['url'] == self.uiCreateSession.line_URL.text() and session['login'] == self.uiCreateSession.line_User.text():
                self.uiCreateSession.label_error.setText('Cette session existe déjà (' + session['name'] + ')')
                return
            
        with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'w') as f:
            if self.uiCreateSession.line_Pwd == '':
                enc_password = ''
            else:
                enc_password = str(self.fernet.encrypt(self.uiCreateSession.line_Pwd.text().encode()))
            data = {
                'name' : self.uiCreateSession.line_Name.text(),
                'url': self.uiCreateSession.line_URL.text(),
                'login': self.uiCreateSession.line_User.text(),
                'password': enc_password
            }
            json_data['sessions'].append(data)
            json.dump(json_data, f)

        self.uiEditSessions.list_sessions.addItem(self.uiCreateSession.line_Name.text())
        self.windowCreateSession.close()
    
    def editSession(self):

        self.windowCreateSession = QtWidgets.QDialog()
        self.uiCreateSession =  Ui_CreateSession()
        self.uiCreateSession.setupUi(self.windowCreateSession)

        with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'r') as f:
            json_data = json.load(f)
            
        self.uiCreateSession.line_Name.setText(json_data['sessions'][self.uiEditSessions.list_sessions.currentRow()]['name'])
        self.uiCreateSession.line_URL.setText(json_data['sessions'][self.uiEditSessions.list_sessions.currentRow()]['url'])
        self.uiCreateSession.line_User.setText(json_data['sessions'][self.uiEditSessions.list_sessions.currentRow()]['login'])
        if json_data['sessions'][self.uiEditSessions.list_sessions.currentRow()]['password'].startswith('b\''):
            pwd = self.fernet.decrypt(json_data['sessions'][self.uiEditSessions.list_sessions.currentRow()]['password'][1:-1])
            pwd = pwd.decode('utf-8')
        else:
            pwd = json_data['sessions'][self.uiEditSessions.list_sessions.currentRow()]['password']
        self.uiCreateSession.line_Pwd.setText(pwd)

        self.uiCreateSession.push_Confirm.clicked.connect(self.modifySession)
        self.uiCreateSession.pushClose.clicked.connect(self.windowEditSessions.close)

        self.windowCreateSession.exec_()

    def modifySession(self):

        with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'r') as f:
            json_data = json.load(f)
        
        json_data['sessions'][self.uiEditSessions.list_sessions.currentRow()]['name'] = self.uiCreateSession.line_Name.text()
        json_data['sessions'][self.uiEditSessions.list_sessions.currentRow()]['url'] = self.uiCreateSession.line_URL.text()
        json_data['sessions'][self.uiEditSessions.list_sessions.currentRow()]['login'] = self.uiCreateSession.line_User.text()
        if self.uiCreateSession.line_Pwd.text() == '':
            enc_password = ''
        else:
            enc_password = str(self.fernet.encrypt(self.uiCreateSession.line_Pwd.text().encode()))
        json_data['sessions'][self.uiEditSessions.list_sessions.currentRow()]['password'] = enc_password

        with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'w') as f:
            json.dump(json_data, f)
        
        self.uiEditSessions.list_sessions.clear()
        with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'r') as f:
            json_data = json.load(f)
            for session in json_data['sessions']:
                self.uiEditSessions.list_sessions.addItem(session['name'])
        self.windowCreateSession.close()

    def deleteSession(self):
        
        # Créez une boîte de dialogue de confirmation
        confirmation = QMessageBox()
        confirmation.setIcon(QMessageBox.Question)
        confirmation.setWindowTitle("Confirmation")
        confirmation.setText("Êtes-vous sûr de vouloir supprimer cette session ?")

        # Ajoutez les boutons "Continuer" et "Annuler"
        confirmation.addButton(QMessageBox.Ok)
        confirmation.addButton(QMessageBox.Cancel)

        # Affichez la boîte de dialogue et attendez la réponse de l'utilisateur
        response = confirmation.exec_()

        # Vérifiez la réponse de l'utilisateur
        if response != QMessageBox.Ok:
            return
        
        with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'r') as f:
            json_data = json.load(f)
        
        json_data['sessions'].pop(self.uiEditSessions.list_sessions.currentRow())

        with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'w') as f:
            json.dump(json_data, f)
        
        self.uiEditSessions.list_sessions.clear()
        with open(os.path.expanduser("~") + '/.vanillaplugin/sessions.json', 'r') as f:
            json_data = json.load(f)
            for session in json_data['sessions']:
                self.uiEditSessions.list_sessions.addItem(session['name'])

    def activate_search_metadatas(self):

        vanilla_url = (self.dlg.line_vanillaURL.text() + '/api/1.0/metadatas?' 
        + 'repositoryID=' + str(self.dlg.comboBox_repository.currentData()) 
        + '&groupID=' + str(self.dlg.comboBox_group.currentData()))

        vanilla_url = vanilla_url.replace('//api', '/api')
        try:
            response = requests.get(vanilla_url, auth=(self.uiLogin.lineUser.text(), self.uiLogin.linePassword.text()))
            if response.status_code == 200:
                response_json = response.json()
                if response_json['status'] == 'success':
                    self.dlg.list_tables.clear()
                    self.dlg.comboBox_metadata.clear()
                    for metadata in response_json['result']:
                        self.dlg.comboBox_metadata.addItem(metadata['name'], metadata['id'])

                    
                    self.dlg.comboBox_metadata.setCurrentIndex(-1)
                    self.dlg.comboBox_metadata.setEnabled(True)
                    self.dlg.label_metadata.setEnabled(True)
                else:
                    self.dlg.list_tables.clear()
                    self.show_error_message(self.tr('Erreur de connexion'))
            else:
                self.dlg.list_tables.clear()
                self.show_error_message(self.tr('Erreur de connexion'))

        except Exception as e:
            self.dlg.list_tables.clear()
            self.show_error_message(self.tr('Erreur de connexion : ') + str(e))


    def get_models(self):

        if self.dlg.comboBox_metadata.isEnabled() == False:
            return
        
        self.dlg.list_tables.clear()
        self.dlg.list_columns.clear()
        self.dlg.comboBox_model.clear()
        self.dlg.comboBox_package.clear()
        self.dlg.comboBox_model.setEnabled(False)
        self.dlg.comboBox_package.setEnabled(False)

        vanilla_url = (self.dlg.line_vanillaURL.text() + '/api/1.0/models?' 
        + 'repositoryID=' + str(self.dlg.comboBox_repository.currentData()) 
        + '&groupID=' + str(self.dlg.comboBox_group.currentData()) 
        + '&metadataName=' + self.dlg.comboBox_metadata.currentText())

        vanilla_url = vanilla_url.replace('//api', '/api')

        try :
            response = requests.get(vanilla_url, auth=(self.uiLogin.lineUser.text(), self.uiLogin.linePassword.text()))
            if response.status_code == 200:
                response_json = response.json()
                if response_json['status'] == 'success':
                    self.dlg.list_tables.clear()
                    self.dlg.comboBox_model.clear()
                    for model in response_json['result']:
                        self.dlg.comboBox_model.addItem(model['name'])
                    
                    self.dlg.comboBox_model.setCurrentIndex(-1)
                    self.dlg.comboBox_model.setEnabled(True)
                    self.dlg.label_model.setEnabled(True)
                
                else:
                    self.show_error_message(self.tr('Erreur de connexion'))
            else:
                self.show_error_message(self.tr('Erreur de connexion'))
        except Exception as e:
            self.show_error_message(self.tr('Erreur de connexion') + str(e))

    def get_packages(self):
            
        if self.dlg.comboBox_model.isEnabled() == False or self.dlg.comboBox_model.count() == 0:
            return
        
        self.dlg.list_tables.clear()
        self.dlg.list_columns.clear()
        self.dlg.comboBox_package.clear()
        self.dlg.comboBox_package.setEnabled(False)


        vanilla_url = (self.dlg.line_vanillaURL.text() + '/api/1.0/packages'
        + '?repositoryID=' + str(self.dlg.comboBox_repository.currentData()) 
        + '&groupID=' + str(self.dlg.comboBox_group.currentData()) 
        + '&metadataName=' + self.dlg.comboBox_metadata.currentText() 
        + '&modelName=' + self.dlg.comboBox_model.currentText())

        vanilla_url = vanilla_url.replace('//api', '/api')

        try :
            response = requests.get(vanilla_url, auth=(self.uiLogin.lineUser.text(), self.uiLogin.linePassword.text()))
            if response.status_code == 200:
                response_json = response.json()
                if response_json['status'] == 'success':
                    self.dlg.list_tables.clear()
                    self.dlg.comboBox_package.clear()
                    for package in response_json['result']:
                        self.dlg.comboBox_package.addItem(package)
                    
                    self.dlg.comboBox_package.setCurrentIndex(-1)
                    self.dlg.comboBox_package.setEnabled(True)
                    self.dlg.label_package.setEnabled(True)
                    
                else:
                    self.show_error_message(self.tr('Erreur de connexion'))
            else:
                self.show_error_message(self.tr('Erreur de connexion'))
        except Exception as e:
            self.show_error_message(self.tr('Erreur de connexion') + str(e))

    def get_queries(self):

        self.allTables = None

        if self.dlg.comboBox_package.isEnabled() == False or self.dlg.comboBox_package.count() == 0:
            return
        self.dlg.list_tables.clear()
        self.dlg.list_columns.clear()


        vanilla_url = (self.dlg.line_vanillaURL.text() 
        + '/api/1.0/queries/saved?'
        + 'repositoryID=' + str(self.dlg.comboBox_repository.currentData()) 
        + '&groupID=' + str(self.dlg.comboBox_group.currentData()) 
        + '&metadataName=' + self.dlg.comboBox_metadata.currentText() 
        + '&modelName=' + self.dlg.comboBox_model.currentText() 
        + '&packageName=' + self.dlg.comboBox_package.currentText())

        vanilla_url = vanilla_url.replace('//api', '/api')

        try :
            response = requests.get(vanilla_url, auth=(self.uiLogin.lineUser.text(), self.uiLogin.linePassword.text()))
            if response.status_code == 200:
                response_json = response.json()
                if response_json['status'] == 'success':
                    self.dlg.list_tables.clear()
                    for query in response_json['result']:
                        self.dlg.list_tables.addItem(query)
                    
                else:
                    self.show_error_message(self.tr('Erreur de connexion'))
            else:
                self.show_error_message(self.tr('Erreur de connexion'))
        except Exception as e:
            self.show_error_message(self.tr('Erreur de connexion') + str(e))

    def get_columns(self):

        self.dlg.list_columns.clear()

        vanilla_url = (self.dlg.line_vanillaURL.text()
                       + '/api/1.0/query/saved?'
                       + 'repositoryID=' + str(self.dlg.comboBox_repository.currentData())
                       + '&groupID=' + str(self.dlg.comboBox_group.currentData())
                       + '&metadataName=' + self.dlg.comboBox_metadata.currentText()
                       + '&modelName=' + self.dlg.comboBox_model.currentText()
                       + '&packageName=' + self.dlg.comboBox_package.currentText()
                       + '&queryName=' + self.dlg.list_tables.currentItem().text())
        
        vanilla_url = vanilla_url.replace('//api', '/api')

        try :
            response = requests.get(vanilla_url, auth=(self.uiLogin.lineUser.text(), self.uiLogin.linePassword.text()))
            if response.status_code == 200:
                response_json = response.json()
                if response_json['status'] == 'success':
                    self.dlg.list_columns.clear()
                    for column in response_json['result']['columns']:
                        self.dlg.list_columns.addItem(column)
                    self.queryLimit = response_json['result']['queryLimit']
                    self.queryDistinct = response_json['result']['queryDistinct']
                    
                else:
                    self.show_error_message(self.tr('Erreur de connexion'))
            else:
                self.show_error_message(self.tr('Erreur de connexion'))
        except Exception as e:
            self.show_error_message(self.tr('Erreur de connexion') + str(e))
            
    def get_tables(self):

        if self.dlg.comboBox_package.isEnabled() == False or self.dlg.comboBox_package.count() == 0:
            return
        
        self.allTables = None

        self.dlg.list_tables.clear()
        self.dlg.list_columns.clear()

        vanilla_url = (self.dlg.line_vanillaURL.text()
                          + '/api/1.0/tables/columns?'
                          + 'repositoryID=' + str(self.dlg.comboBox_repository.currentData())
                          + '&groupID=' + str(self.dlg.comboBox_group.currentData())
                          + '&metadataName=' + self.dlg.comboBox_metadata.currentText()
                          + '&modelName=' + self.dlg.comboBox_model.currentText()
                          + '&packageName=' + self.dlg.comboBox_package.currentText())
        
        vanilla_url = vanilla_url.replace('//api', '/api')

        try :
            response = requests.get(vanilla_url, auth=(self.uiLogin.lineUser.text(), self.uiLogin.linePassword.text()))
            if response.status_code == 200:
                response_json = response.json()
                if response_json['status'] == 'success':
                    self.allTables = response_json['result']
                    for table in response_json['result']:
                        self.dlg.list_tables.addItem(table['tableName'])
                    
                else:
                    self.show_error_message(self.tr('Erreur de connexion'))
            else:
                self.show_error_message(self.tr('Erreur de connexion'))
        except Exception as e:
            self.show_error_message(self.tr('Erreur de connexion') + str(e))
        
    def display_columns(self):
        
        if self.dlg.label_queries.text() == 'Tables :':
            if self.allTables is None:
                return
            index = self.dlg.list_tables.currentRow()
            table = self.allTables[index]
            self.dlg.list_columns.clear()
            self.dlg.combo_lat.clear()
            self.dlg.combo_lon.clear()
            for column in table['columns']:
                self.dlg.list_columns.addItem(column['columnName'])
                self.dlg.combo_lat.addItem(column['columnName'])
                self.dlg.combo_lon.addItem(column['columnName'])
        else: 
            self.get_columns()
            self.dlg.combo_lat.clear()
            self.dlg.combo_lon.clear()
            for i in range(self.dlg.list_columns.count()):
                self.dlg.combo_lat.addItem(self.dlg.list_columns.item(i).text())
                self.dlg.combo_lon.addItem(self.dlg.list_columns.item(i).text())
        
        self.updatePrevisu()

    def nbColumns(self):
        if self.dlg.combo_NColumn.currentIndex() == 0:
            self.dlg.label_lat.setText('Colonne Geo :')
            self.dlg.label_lon.setHidden(True)
            self.dlg.combo_lon.setHidden(True)
        else :
            self.dlg.label_lat.setText('Latitude :')
            self.dlg.label_lon.setHidden(False)
            self.dlg.combo_lon.setHidden(False)

    def importTableInQgis(self):

        if self.dlg.combo_NColumn.currentIndex() == 0:
            if self.dlg.combo_lat.currentIndex() == -1:
                return
        else:
            if self.dlg.combo_lat.currentIndex() == -1 or self.dlg.combo_lon.currentIndex() == -1:
                return
            if self.dlg.combo_lat.currentIndex() == self.dlg.combo_lon.currentIndex():
                return
        #Création de l'url
        vanilla_url = (self.dlg.line_vanillaURL.text()
                          + '/api/1.0/query/result?'
                          + 'repositoryID=' + str(self.dlg.comboBox_repository.currentData())
                          + '&groupID=' + str(self.dlg.comboBox_group.currentData())
                          + '&metadataName=' + self.dlg.comboBox_metadata.currentText()
                          + '&modelName=' + self.dlg.comboBox_model.currentText()
                          + '&packageName=' + self.dlg.comboBox_package.currentText()
                          + '&columns=')
        
        vanilla_url = vanilla_url.replace('//api', '/api')

        if self.dlg.label_queries.text() == 'Tables :':
            index = self.dlg.list_tables.currentRow()
            table = self.allTables[index]
            for column in table['columns']:
                vanilla_url += table['tableName'] + '%3A' + column['columnName'] + '%2C'
            
            vanilla_url = vanilla_url[:-3]
            vanilla_url += '&queryLimit=0&queryDistinct=false'

        else:
            for i in range(self.dlg.list_columns.count()):
                vanilla_url += self.dlg.list_columns.item(i).text() + '%2C'
            vanilla_url = vanilla_url[:-3]
            vanilla_url += '&queryLimit=' + str(self.queryLimit) + '&queryDistinct=' + str(self.queryDistinct).lower()
        try :
            response = requests.get(vanilla_url, auth=(self.uiLogin.lineUser.text(), self.uiLogin.linePassword.text()))
            if response.status_code == 200:
                response_json = response.json()
                if response_json['status'] == 'success':
                    self.addQgisLayer(response_json) 
                    
                else:
                    self.show_error_message('Erreur de connexion')
            else:
                self.show_error_message('Erreur de connexion')
        except Exception as e:
            self.show_error_message('Erreur de connexion ' + str(e))
         
    def setComboLatLon(self):
        # count
        if self.dlg.list_columns.count() == 0:
            self.dlg.combo_NColumn.setEnabled(False)
            self.dlg.combo_lat.clear()
            self.dlg.combo_lon.clear()
            self.dlg.combo_lat.setEnabled(False)
            self.dlg.combo_lon.setEnabled(False)
        else:
            self.dlg.combo_NColumn.setEnabled(True)
            self.dlg.combo_lat.setEnabled(True)
            self.dlg.combo_lon.setEnabled(True)

    def addQgisLayer(self, apiResponse):
        
        fields = QgsFields()
        for i in range(self.dlg.list_columns.count()):
            fields.append(QgsField(self.dlg.list_columns.item(i).text(), QVariant.String))
        
        vl = QgsVectorLayer("Point?crs=EPSG:4326", self.dlg.list_tables.currentItem().text(), "memory")
        vl.dataProvider().addAttributes(fields)
        vl.updateFields()
        vl.startEditing()

        j = 1
        for row in apiResponse['result']:

            if self.dlg.combo_NColumn.currentIndex() == 0:
                wkt_data = str(row[self.dlg.combo_lat.currentIndex()]).split(',')
            else :
                wkt_data = [row[self.dlg.combo_lat.currentIndex()].replace(',','.'), row[self.dlg.combo_lon.currentIndex()].replace(',','.')]

            
            if wkt_data != '' and wkt_data != None and wkt_data != 'null':
                wkt_data = self.geojson_to_wkt(list(wkt_data))

                geometry = QgsGeometry.fromWkt(wkt_data)
                if not geometry.isEmpty():
                    feature = QgsFeature()
                    feature.setGeometry(geometry)   
                    vl.dataProvider().addFeature(feature)
                    feature = vl.getFeature(j)
                    # Ajoutez les valeurs des autres colonnes à l'entité
                    if self.dlg.combo_NColumn.currentIndex() == 0:
                        for i in range(len(row)):
                                # Créez des champs pour les autres colonnes (s'ils n'existent pas déjà)
                                # Définissez la valeur du champ
                                vl.dataProvider().changeAttributeValues({feature.id(): {i : row[i]}})
                    else:
                        for i in range(len(row)):
                                # Créez des champs pour les autres colonnes (s'ils n'existent pas déjà)
                                # Définissez la valeur du champ
                            vl.dataProvider().changeAttributeValues({feature.id(): {i : row[i]}})
            j += 1

        vl.commitChanges()
        if vl is not None:
            # Ajoutez la couche au projet QGIS
            QgsProject.instance().addMapLayer(vl)
            
    def geojson_to_wkt(self, geojson):
        if type(geojson) is list:
            coordinates = geojson
            if coordinates:
                # Format WKT en utilisant les coordonnées GeoJSON
                wkt = f"POINT({coordinates[1]} {coordinates[0]})"
                return wkt
        else:
            # Vérifie si le type est "Polygon"
            if geojson.get("type") == "Polygon":
                coordinates = geojson.get("coordinates", [])
                if coordinates:
                    # Format WKT en utilisant les coordonnées GeoJSON
                    wkt = "POLYGON(("
                    for ring in coordinates:
                        for coord in ring:
                            wkt += f"{coord[0]} {coord[1]}, "
                    # Supprime la virgule finale et ajoute la parenthèse fermante
                    wkt = wkt[:-2] + "))"
                    return wkt
            # Vérifie si le type est "Point"
            elif geojson.get("type") == "Point":
                coordinates = geojson.get("coordinates", [])
                if coordinates:
                    # Format WKT en utilisant les coordonnées GeoJSON
                    wkt = f"POINT({coordinates[0]} {coordinates[1]})"
                    return wkt  
            # Vérifie si le type est "LineString"
            elif geojson.get("type") == "LineString":
                coordinates = geojson.get("coordinates", [])
                if coordinates:
                    # Format WKT en utilisant les coordonnées GeoJSON
                    wkt = "LINESTRING("
                    for coord in coordinates:
                        wkt += f"{coord[0]} {coord[1]}, "
                    # Supprime la virgule finale et ajoute la parenthèse fermante
                    wkt = wkt[:-2] + ")"
                    return wkt
            # Vérifie si le type est "MultiPolygon"
            elif geojson.get("type") == "MultiPolygon":
                coordinates = geojson.get("coordinates", [])
                if coordinates:
                    # Format WKT en utilisant les coordonnées GeoJSON
                    wkt = "MULTIPOLYGON("
                    for polygon in coordinates:
                        wkt += "(("
                        for ring in polygon:
                            for coord in ring:
                                wkt += f"{coord[0]} {coord[1]}, "
                        # Supprime la virgule finale et ajoute la parenthèse fermante
                        wkt = wkt[:-2] + ")), "
                    # Supprime la virgule finale et ajoute la parenthèse fermante
                    wkt = wkt[:-2] + ")"
                    return wkt
                
            return None
        
    def dispQueries(self):

        if self.dlg.push_DisplayQueries.text() == 'Afficher les tables':
            self.dlg.push_DisplayQueries.setText('Afficher les queries')
            self.dlg.label_queries.setText('Tables :')
            self.get_tables()
            self.dlg.push_createQuery.setHidden(True)
        else:
            self.dlg.push_DisplayQueries.setText('Afficher les tables')
            self.dlg.label_queries.setText('Queries :')
            self.get_queries()
            self.dlg.push_createQuery.setHidden(False)

    def get_contracts(self):
        
        if self.dlg.comboBox_repository.isEnabled() == False:
            return
        vanilla_url = (self.dlg.line_vanillaURL.text()
                       + '/api/1.0/architect/contracts?firstResult=0&length=1000')
        
        vanilla_url = vanilla_url.replace('//api', '/api')
        try :
            response = requests.get(vanilla_url, auth=(self.uiLogin.lineUser.text(), self.uiLogin.linePassword.text()))
            if response.status_code == 200:
                response_json = response.json()
                if response_json['status'] == 'success':
                    self.dlg.list_contracts.clear()
                    self.allContracts = response_json['result']['items']
                    for contract in response_json['result']['items']:
                        if contract['docId'] != None:
                            self.dlg.list_contracts.addItem(contract['name'])
                    
                else:
                    self.dlg.list_contracts.clear()
                    self.dlg.list_contracts.addItem('Erreur de connexion')
            else:
                self.dlg.list_contracts.clear()
                self.dlg.list_contracts.addItem('Erreur de connexion')
        except:
            self.dlg.list_contracts.clear()
            self.dlg.list_contracts.addItem('Erreur de connexion')

    def get_contactInfo(self):

        contractIndex = self.getContractIndex()
        contract = self.allContracts[contractIndex]
        self.dlg.label_contractCreationDate.setText('Date de création : ' + self.formatDate(contract['creationDate']))
        self.dlg.label_contractReferent.setText('Fournisseur : ' + contract['parent']['name'])
        if contract['directory'] == None:
            self.dlg.label_contractRepo.setText('Dossier : ')
        else:
            self.dlg.label_contractRepo.setText('Dossier : ' + contract['directory']['name'])

        self.dlg.label_fileName.setText('Fichier : ' + contract['fileVersions']['name'])
        self.dlg.label_fileVersion.setText('Version : V' + str(contract['fileVersions']['lastVersion']['version']))
        self.dlg.label_fileLastModif.setText('Dernière modification : ' + self.formatDate(contract['fileVersions']['lastVersion']['modificationDate']))
        self.dlg.label_fileFormat.setText('Format : ' + contract['fileVersions']['lastVersion']['format'])

    def formatDate(self, date_iso):
        # Convertir la chaîne en objet datetime
        date_obj = datetime.fromisoformat(date_iso)

        # Formater la date comme demandé
        date_formatee = date_obj.strftime("%d/%m/%Y %H:%M")

        return date_formatee
    
    def getContractIndex(self):
        for i in range(len(self.allContracts)):
            if self.allContracts[i]['name'] == self.dlg.list_contracts.currentItem().text():
                return i
        return -1
    
    def importFromArchitect(self):
        
        documentID = self.allContracts[self.getContractIndex()]['docId']

        file_name = (self.allContracts[self.getContractIndex()]['fileVersions']['name'] 
                    + '.' + self.allContracts[self.getContractIndex()]['fileVersions']['lastVersion']['format'])

        destination_path = self.plugin_dir + '/resources/' + file_name
                           

        vanilla_url = (self.dlg.line_vanillaURL.text() +
                       '/api/1.0/architect/document?documentId=' + str(documentID))

        vanilla_url = vanilla_url.replace('//api', '/api')
        response = requests.get(vanilla_url, auth=(self.uiLogin.lineUser.text(), self.uiLogin.linePassword.text()))
        if response.status_code == 200:
            with open(destination_path, 'wb') as f:
                        f.write(response.content)
        else:
            self.show_error_message("Erreur de connexion")
        if self.dlg.label_fileFormat.text() == 'Format : geojson':
            self.importGeoJSON(file_name, destination_path)
        elif self.dlg.label_fileFormat.text() == 'Format : csv':
            self.importCSV(file_name, destination_path)
        elif self.dlg.label_fileFormat.text() == 'Format : json':
            self.importJSON(file_name, destination_path)

    def importGeoJSON(self, file_name, destination_path):
        layer_name = file_name

        v1 = QgsVectorLayer(
            f"{destination_path}", 
            layer_name,
            "ogr"
        ) 

        if not v1.isValid():
            self.show_error_message("Layer failed to load!")
        else:
            QgsProject.instance().addMapLayer(v1)
            self.show_success_message(self.tr('Fichier importé avec succès'))

    def importJSON(self, file_name, destination_path):
        layer_name = file_name
            
        json_layer = QgsVectorLayer(destination_path, layer_name, "ogr")

        if not json_layer.isValid():
            self.show_error_message("Layer failed to load!")
        else:
            QgsProject.instance().addMapLayer(json_layer)
            self.show_success_message(self.tr('Fichier importé avec succès'))

    def importCSV(self, file_name, destination_path):

        layer_name = file_name
        vl = None
        csv_layer = QgsVectorLayer(destination_path, layer_name, "ogr")
        
        if not csv_layer.isValid():
            self.show_error_message(self.tr("Erreur de chargement de la couche !"))
        else:
            QgsProject.instance().addMapLayer(csv_layer)
            
            csv_data = []  # Créez une liste pour stocker les données CSV

            # Ouvrez le fichier CSV et lisez ses données
            try:
                with open(destination_path, 'r', encoding='utf-8') as csv_file:
                    first_line = csv_file.readline()
                    # go back to the beginning of the file
                    csv_file.seek(0)
                    csv_reader = csv.DictReader(csv_file , delimiter=self.detect_delimiter(first_line))
                    for row in csv_reader:
                        csv_data.append(row)
                # Examinez les données du CSV et vérifiez si une colonne "geoshape" existe
                # Si oui, extrayez les données géospatiales et créez la couche
                if 'geo_shape' in csv_data[0] or 'geojson' in csv_data[0]:
                    if 'geo_shape' in csv_data[0]:
                        colname = 'geo_shape'
                    else:
                        colname = 'geojson'
                    
                    # Créez une couche vectorielle vide
                    fields = QgsFields()
                    for key, value in csv_data[0].items():
                        if key != colname:
                            fields.append(QgsField(key, QVariant.String))
                    if json.loads(row[colname]).get("type") == "Polygon":
                        vl = QgsVectorLayer("Polygon?crs=EPSG:4326", f"{layer_name}", "memory")
                    elif json.loads(row[colname]).get("type") == "Point":
                        vl = QgsVectorLayer("Point?crs=EPSG:4326", f"{layer_name}", "memory")
                    elif json.loads(row[colname]).get("type") == "LineString":
                        vl = QgsVectorLayer("LineString?crs=EPSG:4326", f"{layer_name}", "memory")
                    elif json.loads(row[colname]).get("type") == "MultiPolygon":
                        vl = QgsVectorLayer("MultiPolygon?crs=EPSG:4326", f"{layer_name}", "memory")
                    elif json.loads(row[colname]).get("type") == "MultiLineString":
                        vl = QgsVectorLayer("MultiLineString?crs=EPSG:4326", f"{layer_name}", "memory")
                    elif json.loads(row[colname]).get("type") == "MultiPoint":
                        vl = QgsVectorLayer("MultiPoint?crs=EPSG:4326", f"{layer_name}", "memory")
                    vl.dataProvider().addAttributes(fields)
                    vl.updateFields()
                    vl.startEditing()
                    # Parcourez les données du CSV, extrayez les données WKT de la colonne "geoshape"
                    # Créez les entités géométriques et ajoutez-les à la couche
                    i = 1
                    for row in csv_data:
                        
                        wkt_data = row[colname]
                        if wkt_data != '' and wkt_data != None and wkt_data != 'null':
                            wkt_data = self.geojson_to_wkt(json.loads(wkt_data))
                        
                            geometry = QgsGeometry.fromWkt(wkt_data)
                            if not geometry.isEmpty():
                                feature = QgsFeature()
                                feature.setGeometry(geometry)   
                                vl.dataProvider().addFeature(feature)
                                feature = vl.getFeature(i)
                                # Ajoutez les valeurs des autres colonnes à l'entité
                                for key, value in row.items():
                                    if key != colname:
                                        # Créez des champs pour les autres colonnes (s'ils n'existent pas déjà)
                                        # Définissez la valeur du champ
                                        vl.dataProvider().changeAttributeValues({feature.id(): {vl.fields().indexFromName(key): value}})
                        i += 1

                    vl.commitChanges()   

                
                else:
                    # Variable qui permet de savoir si une colonne pour les coordonnées existe
                    has_geo = False
                    pair_geo = None
                    columnName = None

                    # On cherche si une colonne pour les coordonnées existe dans l'énum
                    for columnGeoName in self.enum_geo:
                        if columnGeoName in csv_data[0]:
                            columnName = columnGeoName
                            has_geo = True
                        # Créez une couche vectorielle vide
                        fields = QgsFields()
                        for key, value in csv_data[0].items():
                            if key != columnName:
                                fields.append(QgsField(key, QVariant.String))
                        vl = QgsVectorLayer("Point?crs=EPSG:4326", f"{layer_name}", "memory")
                        vl.dataProvider().addAttributes(fields)
                        vl.updateFields()
                        vl.startEditing()

                        i = 1
                        for row in csv_data:

                            wkt_data = row[columnName]
                            if wkt_data != '' and wkt_data != None and wkt_data != 'null':
                                wkt_data = self.geojson_to_wkt(list(eval(wkt_data)))
                                
                                geometry = QgsGeometry.fromWkt(wkt_data)
                                if not geometry.isEmpty():
                                    feature = QgsFeature()
                                    feature.setGeometry(geometry)   
                                    vl.dataProvider().addFeature(feature)
                                    feature = vl.getFeature(i)
                                    # Ajoutez les valeurs des autres colonnes à l'entité
                                    for key, value in row.items():
                                        if key != columnName:
                                            # Créez des champs pour les autres colonnes (s'ils n'existent pas déjà)
                                            # Définissez la valeur du champ
                                            vl.dataProvider().changeAttributeValues({feature.id(): {vl.fields().indexFromName(key): value}})
                            i += 1

                        vl.commitChanges() 
                        break
                        

                    # On cherche si une colonne pour les coordonnées existe en 2 colonne (longitude et latitude)
                    if not has_geo:
                        pair_geo = None
                        for pair in self.enum_tuples_geo:
                            if pair[0] in csv_data[0] and pair[1] in csv_data[0]:
                                pair_geo = pair
                                break
                        # si une pair est trouvée
                        if pair_geo is not None:
                            # Créez une couche vectorielle vide
                            fields = QgsFields()
                            for key, value in csv_data[0].items():
                                if key != pair_geo[0] and key != pair_geo[1]:
                                    fields.append(QgsField(key, QVariant.String))


                            vl = QgsVectorLayer("Point?crs=EPSG:4326", f"{layer_name}", "memory")
                            vl.dataProvider().addAttributes(fields)
                            vl.updateFields()
                            vl.startEditing()

                            i = 1
                            for row in csv_data:
                                wkt_data = [row[pair_geo[0]].replace(',','.'), row[pair_geo[1]].replace(',','.')]
                                
                                if wkt_data != '' and wkt_data != None and wkt_data != 'null':
                                    wkt_data = self.geojson_to_wkt(wkt_data)
                                    
                                    geometry = QgsGeometry.fromWkt(wkt_data)
                                    if not geometry.isEmpty():
                                        feature = QgsFeature()
                                        feature.setGeometry(geometry)   
                                        vl.dataProvider().addFeature(feature)
                                        feature = vl.getFeature(i)
                                        # Ajoutez les valeurs des autres colonnes à l'entité
                                        for key, value in row.items():
                                            if key != pair_geo[0] and key != pair_geo[1]:
                                                # Créez des champs pour les autres colonnes (s'ils n'existent pas déjà)
                                                # Définissez la valeur du champ
                                                vl.dataProvider().changeAttributeValues({feature.id(): {vl.fields().indexFromName(key): value}})
                                i += 1

                            vl.commitChanges()
                            
            except Exception as e:
                # Si une erreur se produit lors de l'ouverture du fichier, imprimer l'erreur
                self.show_error_message(f"Error csv: {e}")
            self.show_success_message(self.tr('Fichier importé avec succès'))
            
        if vl is not None:
            # Ajoutez la couche au projet QGIS
            QgsProject.instance().addMapLayer(vl)
            # Enlever le fichier csv qui n'a pas de géométrie
            for layer in QgsProject.instance().mapLayers().values():
                if layer.name() == layer_name and str(layer.geometryType()) == 'GeometryType.Null':
                    QgsProject.instance().removeMapLayer(layer)
                    break

    def show_error_message(self, message):
        error_box = QMessageBox()
        error_box.setIcon(QMessageBox.Critical)
        error_box.setWindowTitle('Erreur')
        error_box.setText(message)
        error_box.exec_()

    def show_success_message(self, message):
        success_box = QMessageBox()
        success_box.setIcon(QMessageBox.Information)
        success_box.setWindowTitle('Succès')
        success_box.setText(message)
        success_box.exec_()
    

    def show_info_message(self, message):
        info_box = QMessageBox()
        info_box.setIcon(QMessageBox.Information)
        info_box.setWindowTitle('Information')
        info_box.setText(message)
        info_box.exec_()

    # Détecter le délimiteur d'un fichier CSV (, ou ;)
    def detect_delimiter(self, text):
        if ',' in text:
            return ','
        elif ';' in text:
            return ';'
        else:
            return ','
        
    def openChooseFile(self):

        if self.dlg.list_contracts.currentItem() is None:
            return
        self.windowLayers = QtWidgets.QDialog()
        self.uiLayers =  Ui_ChooseLayer()
        self.uiLayers.setupUi(self.windowLayers)

        # Afficher les couches Qgis en cours dans le list widget 
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            self.uiLayers.list_layers.addItem(layer.name())

        self.uiLayers.push_confirm.clicked.connect(self.exportInArchitect)
        self.uiLayers.push_cancel.clicked.connect(self.windowLayers.close)

        self.windowLayers.exec_()

    def exportInArchitect(self):
        
        file = QgsProject.instance().mapLayersByName(self.uiLayers.list_layers.currentItem().text())[0]
        file_path = file.dataProvider().dataSourceUri().split('|')[0]

        if file_path.startswith('memory?') or file_path.startswith('dbname='):
            # Si la couche est chargée en mémoire, l'enregistrer dans resources au format geojson
        
            try: 
                file_path = self.plugin_dir + '/resources/' + file.name().replace('.csv', '') + '.geojson'
                self.save_layer_as_geojson(file, file_path)
            except Exception as e:
                self.show_error_message(self.tr('Erreur lors de la sauvegarde de la couche, veuillez l\'enregistrer sur le disque.'), e)
                return
        if not os.path.exists(file_path):
            self.show_error_message(self.tr('Erreur lors de la sauvegarde de la couche, veuillez l\'enregistrer sur le disque.'))
            return
        
        self.windowLayers.close()
        
        documentID = self.allContracts[self.getContractIndex()]['docId']

        vanilla_url = (self.dlg.line_vanillaURL.text()
                       + '/api/1.0/architect/document/upload')
        vanilla_url = vanilla_url.replace('//api', '/api')
        
        data = {
            'type': 0,
            'documentId': documentID,
            # 'format' : self.allContracts[self.getContractIndex()]['fileVersions']['lastVersion']['format']
            'format' : 'geojson'
        }
        with open(file_path, 'rb') as f:
            try:
                response = requests.post(vanilla_url, auth=(self.uiLogin.lineUser.text(), self.uiLogin.linePassword.text()), files={'file': f}, data=data)
                if response.status_code == 200:
                    self.show_success_message(self.tr('Fichier exporté avec succès'))
                    self.get_contracts()
                else:
                    self.show_error_message(self.tr('Erreur de connexion'))
            except Exception as e:
                self.show_error_message(self.tr('Erreur de connexion'), e)

        


    def save_layer_as_geojson(self, layer, output_geojson_path):
       

        project = QgsProject.instance()
        # Initialiser l'application QGIS
        QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())
        Processing.initialize()
        if layer.type() == QgsMapLayer.VectorLayer and (layer.dataProvider().name() == 'memory' or layer.dataProvider().name() == 'postgres'):
            # We do not manage sanitized name colision (if your
            # layer name is the same, code will try to write to
            # a GPKG with the same name and the same layer...)
            layer_name = layer.name().lower().replace(' ', '_')
            layer_name = layer_name.replace('.csv', '')
            out = Processing.runAlgorithm("native:savefeatures", {
                'INPUT': layer,
                'OUTPUT': output_geojson_path,
                'LAYER_NAME':'',
                'DATASOURCE_OPTIONS':'',
                'LAYER_OPTIONS':''}
            )
            layer.setDataSource(f"{out['OUTPUT']}", layer.name(), 'ogr')
        project.write()
       

    def setupTools(self):
        if self.dlg.tabWidget.currentIndex() == 2:
            exportable_layers = QgsProject.instance().mapLayers().values()
            
            self.dlg.combo_firstLayer.clear()
            self.dlg.combo_secondLayer.clear()

            dot_icon = QIcon(os.path.join(self.plugin_dir, 'img', 'dot_icon.png'))
            shape_icon = QIcon(os.path.join(self.plugin_dir, 'img', 'shape_icon.png'))
            line_icon = QIcon(os.path.join(self.plugin_dir, 'img', 'line_icon.png'))

            for layer in exportable_layers:
                item_name = layer.name()        
                if item_name != 'OpenStreetMap' and str(layer.geometryType()) != 'GeometryType.Null':
                    item = item_name
                    if layer.geometryType() == QgsWkbTypes.PointGeometry:
                        icon = dot_icon
                    elif layer.geometryType() == QgsWkbTypes.LineGeometry:
                        icon = line_icon
                    elif layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                        icon = shape_icon
                    else:
                        icon = dot_icon

                    self.dlg.combo_firstLayer.addItem(icon, item)

    def changeGeoLayers(self):
        geo_type = self.getSelectionType(self.dlg.combo_firstLayer.currentText())
        
        # layout = QtWidgets.QVBoxLayout()
        # self.dlg.scrollAreaWidgetContents.setLayout(layout)

        if geo_type == 'GeometryType.Point' or geo_type == 'GeometryType.MultiPoint':
            icon = QIcon(os.path.join(self.plugin_dir, 'img', 'dot_icon.png'))
        elif geo_type == 'GeometryType.Polygon' or geo_type == 'GeometryType.MultiPolygon':
            icon = QIcon(os.path.join(self.plugin_dir, 'img', 'shape_icon.png'))
        elif geo_type == 'GeometryType.Line' or geo_type == 'GeometryType.MultiLine':
            icon = QIcon(os.path.join(self.plugin_dir, 'img', 'line_icon.png'))
        else:
            icon = QIcon(os.path.join(self.plugin_dir, 'img', 'add_icon.png'))

        self.dlg.combo_secondLayer.clear()

        exportable_layers = QgsProject.instance().mapLayers().values()
        for layer in exportable_layers:
            if layer.name() != self.dlg.combo_firstLayer.currentText() and layer.name() != 'OpenStreetMap':
                if str(layer.geometryType()) == geo_type:
                    self.dlg.combo_secondLayer.addItem(icon, layer.name())

                    

    def updateListLayers(self):
        if self.dlg.combo_operation.currentIndex() == 0:
            self.dlg.list_additionnalLayers.clear()
            for layer in QgsProject.instance().mapLayers().values():
                if (layer.name() != self.dlg.combo_firstLayer.currentText() 
                    and layer.name() != self.dlg.combo_secondLayer.currentText() 
                    and layer.name() != 'OpenStreetMap'):
                    
                    if str(layer.geometryType()) == self.getSelectionType(self.dlg.combo_firstLayer.currentText()):
                        self.dlg.list_additionnalLayers.addItem(layer.name())
                    

    def getSelectionType(self, layer_name):
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if layer.name() == layer_name and str(layer.geometryType()) != 'GeometryType.Null':
                return str(layer.geometryType())
        return 'GeometryType.Null'
    
    def handleComboOp(self):
        if self.dlg.combo_operation.currentIndex() == 0:
            self.dlg.list_additionnalLayers.setHidden(False)
            self.dlg.label_scroll.setHidden(False)
            self.dlg.check_centroide.setHidden(True)
            self.dlg.combo_secondLayer.setEnabled(True)

        elif self.dlg.combo_operation.currentIndex() == 4:
            self.dlg.list_additionnalLayers.setHidden(True)
            self.dlg.label_scroll.setHidden(True)
            self.dlg.check_centroide.setHidden(False)
            self.dlg.combo_secondLayer.setEnabled(False)

        else:
            self.dlg.list_additionnalLayers.setHidden(True)
            self.dlg.label_scroll.setHidden(True)
            self.dlg.check_centroide.setHidden(True)
            self.dlg.combo_secondLayer.setEnabled(True)


    def calculateLayer(self):

        if self.dlg.combo_operation.currentIndex() == 0:
            self.fusionner_couches_couche()
        elif self.dlg.combo_operation.currentIndex() == 1:
            self.difference_couches_couche()
        elif self.dlg.combo_operation.currentIndex() == 2:
            self.union_couches_couche()
        elif self.dlg.combo_operation.currentIndex() == 3:
            self.intersection_couches_couche()
        elif self.dlg.combo_operation.currentIndex() == 4:
            self.centroids_couches_couche()

    def fusionner_couches_couche(self):
        # Récupérer les couches
        layers = []
        for couche in QgsProject.instance().mapLayersByName(self.dlg.combo_firstLayer.currentText()):
            if str(couche.geometryType()) != 'GeometryType.Null':
                layers.append(couche)
                break

        
        if self.dlg.combo_secondLayer.currentText() != '':
            for couche in QgsProject.instance().mapLayersByName(self.dlg.combo_secondLayer.currentText()):
                if str(couche.geometryType()) != 'GeometryType.Null':
                    layers.append(couche)
                    break


        for i in range (self.dlg.list_additionnalLayers.count()):
            # Si l'item est selectionné
            if self.dlg.list_additionnalLayers.item(i).isSelected(): 
                layerName = self.dlg.list_additionnalLayers.item(i).text()
                for couche in QgsProject.instance().mapLayersByName(layerName):
                    if str(couche.geometryType()) != 'GeometryType.Null':
                        layers.append(couche)
                        break
        
        if self.dlg.line_layerName.text() == '':

            i_str = ''
            i=0
            while QgsProject.instance().mapLayersByName('Fusion' + i_str):
                i += 1
                i_str = '_'  + str(i)

            result_layer_path = self.plugin_dir + '/resources/' + 'Fusion' + i_str + '.geojson'
            layerName = 'Fusion' + i_str
        else:
            i_str = ''
            i = 0
            while QgsProject.instance().mapLayersByName(self.dlg.line_layerName.text() + i_str):
                i += 1
                i_str = '_'  + str(i)
            result_layer_path = self.plugin_dir + '/resources/' + self.dlg.line_layerName.text() + i_str + '.geojson'
            layerName = self.dlg.line_layerName.text() + i_str 

        # Initialiser l'application QGIS
        QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())
        Processing.initialize()
        # Définir les paramètres de l'algorithme de fusion
        parameters = {
            'LAYERS': layers,
            'CRS': 'epsg:4326',
            'OUTPUT': result_layer_path
        }
        # Exécuter l'algorithme de fusion
        try:
            Processing.runAlgorithm("native:mergevectorlayers", parameters)
            # Ajouter la couche fusionnée à la carte de QGIS
            
            result_layer = QgsVectorLayer(result_layer_path, layerName , 'ogr')
            
            if result_layer.isValid():
                QgsProject.instance().addMapLayer(result_layer)
                self.show_success_message(self.tr('Couche fusionnée créée avec succès'))
                
                    
        except Exception as e:
            self.show_error_message(self.tr(f'Erreur lors de la fusion des couches. {e}'))
            # delete the file in the folder
            os.remove(result_layer_path)
            return

    def difference_couches_couche(self):
        
        # Récupérer les couches
        layers = []
        for couche in QgsProject.instance().mapLayersByName(self.dlg.combo_firstLayer.currentText()):
            if str(couche.geometryType()) != 'GeometryType.Null':
                layers.append(couche)
                break

        
        if self.dlg.combo_secondLayer.currentText() != '':
            for couche in QgsProject.instance().mapLayersByName(self.dlg.combo_secondLayer.currentText()):
                if str(couche.geometryType()) != 'GeometryType.Null':
                    layers.append(couche)
                    break
        
        if self.dlg.line_layerName.text() == '':

            i_str = ''
            i=0
            while QgsProject.instance().mapLayersByName('Différence' + i_str):
                i += 1
                i_str = '_'  + str(i)

            result_layer_path = self.plugin_dir + '/resources/' + 'Différence' + i_str + '.geojson'
            layerName = 'Différence' + i_str
        else:
            i_str = ''
            i = 0
            while QgsProject.instance().mapLayersByName(self.dlg.line_layerName.text() + i_str):
                i += 1
                i_str = '_'  + str(i)
            result_layer_path = self.plugin_dir + '/resources/' + self.dlg.line_layerName.text() + i_str + '.geojson'
            layerName = self.dlg.line_layerName.text() + i_str 

        
        # Initialiser l'application QGIS
        QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())
        Processing.initialize()

        # Définir les paramètres de l'algorithme de différence
        parameters = {
            'INPUT': layers[0],
            'OVERLAY': layers[1],
            'OUTPUT': result_layer_path
        }
        # Exécuter l'algorithme de différence
        try:
            
            Processing.runAlgorithm("native:difference", parameters)
            # Ajouter la couche calculée à la carte de QGIS
            
            result_layer = QgsVectorLayer(result_layer_path, layerName , 'ogr')
            
            if result_layer.isValid():
                QgsProject.instance().addMapLayer(result_layer)
                self.show_success_message(self.tr('Différence créée avec succès'))                
                
        except Exception as e:
            self.show_error_message(self.tr(f'Erreur lors de la différence des couches, vérifier que les couches sont compatibles. {e}'))
            # delete the file in the folder
            os.remove(result_layer_path)
            return

    def union_couches_couche(self):
        # Récupérer les couches
        layers = []
        for couche in QgsProject.instance().mapLayersByName(self.dlg.combo_firstLayer.currentText()):
            if str(couche.geometryType()) != 'GeometryType.Null':
                layers.append(couche)
                break

        
        if self.dlg.combo_secondLayer.currentText() != '':
            for couche in QgsProject.instance().mapLayersByName(self.dlg.combo_secondLayer.currentText()):
                if str(couche.geometryType()) != 'GeometryType.Null':
                    layers.append(couche)
                    break
        
        if self.dlg.line_layerName.text() == '':

            i_str = ''
            i=0
            while QgsProject.instance().mapLayersByName('Union' + i_str):
                i += 1
                i_str = '_'  + str(i)

            result_layer_path = self.plugin_dir + '/resources/' + 'Union' + i_str + '.geojson'
            layerName = 'Union' + i_str
        else:
            i_str = ''
            i = 0
            while QgsProject.instance().mapLayersByName(self.dlg.line_layerName.text() + i_str):
                i += 1
                i_str = '_'  + str(i)
            result_layer_path = self.plugin_dir + '/resources/' + self.dlg.line_layerName.text() + i_str + '.geojson'
            layerName = self.dlg.line_layerName.text() + i_str 

        # Initialiser l'application QGIS
        QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())
        Processing.initialize()

        # Définir les paramètres de l'algorithme d'union
        parameters = {
            'INPUT': layers[0],
            'OVERLAY': layers[1],
            'OUTPUT': result_layer_path
        }
        # Exécuter l'algorithme d'union
        try:
            
            Processing.runAlgorithm("native:union", parameters)
            # Ajouter la couche calculée à la carte de QGIS
            
            result_layer = QgsVectorLayer(result_layer_path, layerName  , 'ogr')
            
            if result_layer.isValid():
                QgsProject.instance().addMapLayer(result_layer)
                self.show_success_message(self.tr('Union créée avec succès'))
                
                
        except Exception as e:
            self.show_error_message(self.tr(f'Erreur lors de l\'union des couches, vérifier que les couches sont compatibles. {e}'))
            # delete the file in the folder
            os.remove(result_layer_path)
            return

    def intersection_couches_couche(self):
        # Récupérer les couches
        layers = []
        for couche in QgsProject.instance().mapLayersByName(self.dlg.combo_firstLayer.currentText()):
            if str(couche.geometryType()) != 'GeometryType.Null':
                layers.append(couche)
                break

        
        if self.dlg.combo_secondLayer.currentText() != '':
            for couche in QgsProject.instance().mapLayersByName(self.dlg.combo_secondLayer.currentText()):
                if str(couche.geometryType()) != 'GeometryType.Null':
                    layers.append(couche)
                    break
        
        if self.dlg.line_layerName.text() == '':

            i_str = ''
            i=0
            while QgsProject.instance().mapLayersByName('Intersection' + i_str):
                i += 1
                i_str = '_'  + str(i)

            result_layer_path = self.plugin_dir + '/resources/' + 'Intersection' + i_str + '.geojson'
            layerName = 'Intersection' + i_str
        else:
            i_str = ''
            i = 0
            while QgsProject.instance().mapLayersByName(self.dlg.line_layerName.text() + i_str):
                i += 1
                i_str = '_'  + str(i)
            result_layer_path = self.plugin_dir + '/resources/' + self.dlg.line_layerName.text() + i_str + '.geojson'
            layerName = self.dlg.line_layerName.text() + i_str 

        
        # Initialiser l'application QGIS
        QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())
        Processing.initialize()

        # Définir les paramètres de l'algorithme d'intersection
        parameters = {
            'INPUT': layers[0],
            'OVERLAY': layers[1],
            'OUTPUT': result_layer_path
        }
        # Exécuter l'algorithme d'intersection
        try:
            
            Processing.runAlgorithm("native:intersection", parameters)
            # Ajouter la couche calculée à la carte de QGIS
            
            result_layer = QgsVectorLayer(result_layer_path, layerName , 'ogr')
            
            if result_layer.isValid():
                QgsProject.instance().addMapLayer(result_layer)
                self.show_success_message(self.tr('Intersection créée avec succès'))
                
        except Exception as e:
            self.show_error_message(self.tr(f'Erreur lors de l\'intersection des couches, vérifier que les couches sont compatibles. {e}'))
            os.remove(result_layer_path)
            return
        
    def centroids_couches_couche(self):
        
        # Récupérer les couches
        layer = None
        for couche in QgsProject.instance().mapLayersByName(self.dlg.combo_firstLayer.currentText()):
            if str(couche.geometryType()) != 'GeometryType.Null':
                layer = couche
                break
        
        if self.dlg.line_layerName.text() == '':

            i_str = ''
            i=0
            while QgsProject.instance().mapLayersByName('Centroïde' + i_str):
                i += 1
                i_str = '_'  + str(i)

            result_layer_path = self.plugin_dir + '/resources/' + 'Centroïde' + i_str + '.geojson'
            layerName = 'Centroïde' + i_str
        else:
            i_str = ''
            i = 0
            while QgsProject.instance().mapLayersByName(self.dlg.line_layerName.text() + i_str):
                i += 1
                i_str = '_'  + str(i)
            result_layer_path = self.plugin_dir + '/resources/' + self.dlg.line_layerName.text() + i_str + '.geojson'
            layerName = self.dlg.line_layerName.text() + i_str 

        # Initialiser l'application QGIS
        QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())
        Processing.initialize()

        # Définir les paramètres de l'algorithme de centroide
        if self.dlg.check_centroide.isChecked():
            all_parts = True
        else:
            all_parts = False
        parameters = {
            'INPUT': layer,
            'ALL_PARTS': all_parts, 
            'OUTPUT': result_layer_path
        }
        # Exécuter l'algorithme de centroide
        try:
            
            
            Processing.runAlgorithm("native:centroids", parameters)
            # Ajouter la couche calculée à la carte de QGIS
            
            result_layer = QgsVectorLayer(result_layer_path, layerName, 'ogr')
            
            if result_layer.isValid():
                QgsProject.instance().addMapLayer(result_layer)
                self.show_success_message(self.tr('Centroïde créée avec succès'))                
                
        except Exception as e:
            self.show_error_message(self.tr(f'Erreur lors du calcul des centroides. {e}'))
            # delete the file in the folder
            os.remove(result_layer_path)
            return

    def showPrevisu(self):
        if self.dlg.check_previsu.isChecked():
            self.dlg.setMaximumSize(800, 477)
            self.dlg.resize(800, 477)
        else:
            self.dlg.setMaximumSize(560, 477)
            self.dlg.resize(560, 477)

    def updatePrevisu(self):
        
        if self.dlg.combo_NColumn.currentIndex() == 0:
            if self.dlg.combo_lat.currentIndex() == -1:
                return
        else:
            if self.dlg.combo_lat.currentIndex() == -1 or self.dlg.combo_lon.currentIndex() == -1:
                return
            if self.dlg.combo_lat.currentIndex() == self.dlg.combo_lon.currentIndex():
                return
        self.dlg.tableWidget.clear()
        if self.dlg.list_columns.count() == 0:
            return
        
        json_data = []
        #Création de l'url
        vanilla_url = (self.dlg.line_vanillaURL.text()
                          + '/api/1.0/query/result?'
                          + 'repositoryID=' + str(self.dlg.comboBox_repository.currentData())
                          + '&groupID=' + str(self.dlg.comboBox_group.currentData())
                          + '&metadataName=' + self.dlg.comboBox_metadata.currentText()
                          + '&modelName=' + self.dlg.comboBox_model.currentText()
                          + '&packageName=' + self.dlg.comboBox_package.currentText()
                          + '&columns=')
        
        vanilla_url = vanilla_url.replace('//api', '/api')

        if self.dlg.label_queries.text() == 'Tables :':
            index = self.dlg.list_tables.currentRow()
            table = self.allTables[index]
            for column in table['columns']:
                vanilla_url += table['tableName'] + '%3A' + column['columnName'] + '%2C'
            
            vanilla_url = vanilla_url[:-3]
            vanilla_url += '&queryLimit=0&queryDistinct=false'

        else:
            for i in range(self.dlg.list_columns.count()):
                vanilla_url += self.dlg.list_columns.item(i).text() + '%2C'
            vanilla_url = vanilla_url[:-3]
            vanilla_url += '&queryLimit=' + str(self.queryLimit) + '&queryDistinct=' + str(self.queryDistinct).lower()
        
        try :
            response = requests.get(vanilla_url, auth=(self.uiLogin.lineUser.text(), self.uiLogin.linePassword.text()))
            if response.status_code == 200:
                response_json = response.json()
                if response_json['status'] == 'success':
                        json_data = response_json['result']
                else:
                    return
        except Exception as e:
            self.show_error_message(self.tr('Erreur de connexion ') + str(e))
            return
        if type(json_data) == dict:
            return
        if json_data != []:
            if json_data[0]: 
                
                headers = []
                for i in range(self.dlg.list_columns.count()):
                    headers.append(self.dlg.list_columns.item(i).text())
                nb_columns = len(headers)
                nb_rows = len(json_data)
                if nb_rows > 100:
                    nb_rows = 100
                self.dlg.tableWidget.setRowCount(nb_rows)
                self.dlg.tableWidget.setColumnCount(nb_columns)
                self.dlg.tableWidget.setHorizontalHeaderLabels(headers)

                for i in range(nb_rows):
                    for j in range(nb_columns):
                        self.dlg.tableWidget.setItem(i, j, QtWidgets.QTableWidgetItem(str(json_data[i][j])))

    def openTableWindow(self):
        self.windowTable = TableWindow()

        self.windowTable.table.setColumnCount(self.dlg.tableWidget.columnCount())
        self.windowTable.table.setRowCount(self.dlg.tableWidget.rowCount())

        
        self.windowTable.table.setHorizontalHeaderLabels(self.dlg.tableWidget.horizontalHeaderItem(i).text() for i in range(self.dlg.tableWidget.columnCount()))
        for row in range(self.dlg.tableWidget.rowCount()):
            for col in range(self.dlg.tableWidget.columnCount()):
                item = self.dlg.tableWidget.item(row, col)
                if item is not None:
                    new_item = QtWidgets.QTableWidgetItem(item.text())
                    self.windowTable.table.setItem(row, col, new_item)
        self.windowTable.show()

    
    def openCrateNewContract(self):
        self.windowCreateContract = QtWidgets.QDialog()
        self.uiCreateContract = Ui_createContract()
        self.uiCreateContract.setupUi(self.windowCreateContract)
        
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if layer.name() != 'OpenStreetMap':
                self.uiCreateContract.combo_selectedLayer.addItem(layer.name())
        
        json_data = []
        vanilla_url = (self.dlg.line_vanillaURL.text() + '/api/1.0/architect/suppliers')

        vanilla_url = vanilla_url.replace('//api', '/api')

        try :
            response = requests.get(vanilla_url, auth=(self.uiLogin.lineUser.text(), self.uiLogin.linePassword.text()))
            if response.status_code == 200:
                response_json = response.json()
                if response_json['status'] == 'success':
                        json_data = response_json['result']
                else:
                    return
        except Exception as e:
            self.show_error_message(self.tr('Erreur de connexion ') + str(e))
            return
        
        if type(json_data) == dict:
            return
        if json_data != []:
            if json_data[0]: 
                for supplier in json_data:
                    self.uiCreateContract.combo_supplier.addItem(supplier['name'], supplier['id'])

        self.uiCreateContract.push_createContract.clicked.connect(self.createContract)
        self.uiCreateContract.pushClose.clicked.connect(self.windowCreateContract.close)

        self.windowCreateContract.exec_()

    def createContract(self):
        
        
        supplierID = self.uiCreateContract.combo_supplier.currentData()

        contractName = self.uiCreateContract.line_contractName.text()
        if contractName == '':
            self.show_error_message(self.tr('Veuillez saisir un nom de contrat'))
            return
        externalSource = self.uiCreateContract.line_externalSource.text()
        externalId = self.uiCreateContract.line_externalId.text()

        vanilla_url = (self.dlg.line_vanillaURL.text()
                       + '/api/1.0/architect/contract/create?'
                       + 'supplierId=' + str(supplierID))
        vanilla_url = vanilla_url.replace('//api', '/api')

        data = {
            'name': contractName,
            'externalSource': externalSource,
            'externalId': externalId
        }

        try :
            response = requests.post(vanilla_url, auth=(self.uiLogin.lineUser.text(), self.uiLogin.linePassword.text()), json=data)
            if response.status_code == 200:
                response_json = response.json()
                if response_json['status'] == 'success':
                    contractId = response_json['result']['id']
                    self.show_success_message(self.tr('Contrat créé avec succès'))   
                else:
                    self.show_error_message(self.tr('Erreur lors de la création du contrat'))
                    return            
            
            vanilla_url_upload = (self.dlg.line_vanillaURL.text()
                    + '/api/1.0/architect/document/upload')
            
            vanilla_url_upload = vanilla_url_upload.replace('//api', '/api')

            file = QgsProject.instance().mapLayersByName(self.uiCreateContract.combo_selectedLayer.currentText())[0]
            file_path = file.dataProvider().dataSourceUri().split('|')[0]
            file_format = self.get_layer_format(file)
            if file_format == 'Memory Layer':
                try: 
                    file_path = self.plugin_dir + '/resources/' + file.name().replace('.csv', '') + '.geojson'
                    self.save_layer_as_geojson(file, file_path)
                    file_format = 'geojson'
                except Exception as e:
                    self.show_error_message(self.tr('Erreur lors de la sauvegarde de la couche, veuillez l\'enregistrer sur le disque.') + str(e))
                    return
            if not os.path.exists(file_path):
                self.show_error_message(self.tr('Erreur lors de la sauvegarde de la couche, veuillez l\'enregistrer sur le disque.'))
                return
            
            data = {
            'type': 0,
            'format' : file_format,
            'contractId' : contractId,
            'documentId': -1
            }
            with open(file_path, 'rb') as f:
                response2 = requests.post(vanilla_url_upload, auth=(self.uiLogin.lineUser.text(), self.uiLogin.linePassword.text()),files={'file': f} ,data=data)
                if response2.status_code == 200:
                    self.show_success_message(self.tr('Fichier exporté avec succès'))
                else:
                    self.show_error_message(self.tr('Erreur de connexion') + str(response2.status_code) + str(response2.text))
        except Exception as e:
            self.show_error_message(self.tr('Erreur de connexion ') + str(e))
            return
        self.get_contracts()
        self.windowCreateContract.close()
        

    def get_layer_format(self, layer):
        # Vérifier si la couche est valide
        if layer.isValid():
            # Obtenir le type de fournisseur de la couche (par exemple, 'ogr' pour les couches provenant de fichiers)
            provider_type = layer.providerType()

            # Mapper le type de fournisseur au format correspondant
            if provider_type == 'ogr':
                # Obtenir le format spécifique du fournisseur (par exemple, 'GeoJSON' pour les couches GeoJSON)
                provider_format = layer.dataProvider().dataSourceUri().split('|')[0].split('.')[-1].lower()
                return provider_format
            elif provider_type == 'memory':
                return 'Memory Layer'
            else:
                return 'Autre'

        return 'Couche invalide'